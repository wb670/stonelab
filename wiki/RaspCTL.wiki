= 什么是RaspCTL =
RaspCTL是Raspberry Pi和Control字母的组合，表示树莓派控制端。
RaspCTL是一款通过手机终端（泛义上包括手机，平板，电脑等设备）控制[http://www.raspberrypi.org/ 树莓派]的软件。

目前，通过Raspberry&RaspCTL组合，打造成家庭多媒体播放机顶盒，在此场景中，RaspCTL非常类似[http://xbmc.org XBMC]平台。

未来，会不断扩展RaspCTL功能，成为控制家庭物联网的设备中心，比如控制摄像头，空调开关等。此乃后话，按下不表。

= 为什么选择Raspberry Pi&RaspCTL =
== 为什么选择Raspberry Pi ==

我们先来看看Raspberry Pi的相关参数：
|| CPU || 700 MHz， ARM1176JZF-S ||
|| GPU（显卡）  || Broadcom VideoCore IV，OpenGL ES 2.0， 1080p30 h.264/MPEG-4 AVC high-profile decoder ||
|| MEM（内存） || 512M ||
|| 分辨率 || 1080P ||
|| 输出接口 || 1*SD口 2*USB口 1*音频口 1*HDMI口 1*网卡 ||
|| 尺寸 || 85.6 x 53.98 x 17mm （一张信用卡大小） ||
|| 价格 || $35 ||

好吧，一起来总结下Raspberry Pi的优势吧

  * 小巧：只有一张信用卡大小
  * GPU强悍： 硬解1080P，30帧/S，通俗地将，差不多是iphone4S手机的2倍性能
  * 输出接口丰富： 包括2*USB，1*HDMI
  * 性价比高：$35

从这些特性看，Raspberry非常合适充当高清视频播放机顶盒，来替代目前的华数机顶盒（华数官方垄断，费用高，质量差）。
家庭中，只要购置了Raspberry Pi和宽带，高清电影电视，免费看。 ：）

== 为什么选择RaspCTL ==
只有一个原因：Raspberry Pi CPU很弱：700MHZ。
同样，我们来看一组数据：
  * Raspbian Terminal下 CPU LOAD在0.2左右
  * Raspbian XWindows下， CPU占用率差不多在70%以上
  * [http://xbian.org/ XBian]下，CPU占用率在95%以上

如果，Raspberry Pi CPU能强悍那么一点点，那么XBian一定是首选，我也不会重新创造RaspCTL这个轮子了。只是目前，XBMC在Raspberry Pi（XBian）上的性能太糟糕了。
从数据看，只有在Raspbian Terminal下的性能，才能符合用户的期望，所以作者编写了RaspCTL这个控制端。通过手机终端的界面，来操作Raspbian Terminal，实现多媒体播放的功能。

= RaspCTL功能特性 =
=== V0.1.0 ===
  # 支持视屏，音频播放 
     * 支持播放，暂停，停止，快进，快退，播放列表，上一首，下一首等
  # 支持本地文件查看
     * 查看多媒体文件
  # 配置系统信息
     * 配置多媒体文件根路径等
  # 视频网站真实URL分析
     * 支持包括优酷，土豆，迅雷，百度等82个网站视频URL分析
  # 制定Plugins规范
     * 可非常方便开发RaspCTL Pugin
=== V0.1.1 ===
  # 增加百度视频插件
     * 使用百度视屏搜索，支持优酷，迅雷看看，PPS，乐视，CNTV，电影网，风行网视频
  # 树莓派 重启 & 关机 功能
  # 增加首页

= 使用者文档 =
== 如何安装RaspCTL ==
  # 下载[http://stonelab.googlecode.com/files/raspctl-0.1.0.tar.gz RaspCTL]
     # 下载，解压到指定目录
     # 或者直接使用svn地址： svn co [https://stonelab.googlecode.com/svn/tags/raspctl-0.1.0] RaspCTL 
  # 安装RaspCTL
     # chmox +x bin/install.sh; bin/install.sh 
     # 会自动安装RaspCTL依赖的第三方库，主要是python-webpy python-jinja2 python-pexpect依赖

== 如何使用RaspCTL ==
  # 启动RaspCTL服务
     * bin/start.sh
     * 启动后，在你手机浏览器上输入：
     * [http://xxx.xxx.xxx.xxx:8000/config] 配置你树莓派上本地多媒体文件根目录
     * [http://xxx.xxx.xxx.xxx:8000/player] 进入播放器
     * 点击添加，选择本地多媒体文件
     * 点击播放，暂停等功能
  # 关闭RaspCTL服务
     * bin/shutdown.sh

== 常见问题 ==
  * Q：如何自启动RaspCTL服务
    * 将 bin/start.sh 配置到树莓派的/etc/rc.local exit之前。 同理，你在rc.local中可以启动其他任何服务；
  * Q：如何使用80端口
    * debian系统禁用了小于1024的端口，所以RaspCTL只有使用8000端口。可以通过iptable将80端口请求转发到8000端口： iptables -t nat -A PREROUTING -p tcp --dport 81 -j REDIRECT --to-ports 8080


= 开发者文档 =

== 类库API ==
* Omxplayer
|| play || 播放，可以指定播放列表中任一一个资源 ||  
|| pause || 暂停播放 || 
|| resume || 恢复播放 ||
|| stop || 停止播放 || 
|| lseek || 快退， 快退30秒， 参数为True的话，快退10分钟 || 
|| rseek || 快进， 快进30秒，参数为True的话，快进10分钟 || 
|| prev || 播放上一首 ||  
|| next || 播放下一首 || 
|| set_playlist || 设置播放列表 ||
|| add_playitem || 添加多媒体资源到播放列表中, 参数为 ('url', 'name') 资源地址， 资源显示名  || 
|| del_playitem || 清空播放列表 || 
|| sort_playitem || 播放列表排序 ||
|| set_dev || 设置输出设备， hdmi接口 或者 本地音频接口 || 
|| set_loop || 设置播放模式：顺序，循环 || 
|| get_info || 获取播放器信息，如播放状态等 || 

* LocalFile
|| get_mediapath || 获得多媒体文件根目录路径 || 
|| list || 获取一个目录下的所有资源 || 
|| list_all || 递归获取一个目录下的所有资源 ||

* Config
|| load || 获取raspctl.cnf中的配置信息  ||
|| save || 更新raspctl.cnf中的配置信息  ||

* MediaUrl 
|| get_urls || 获取网站url对应的真实视屏url地址信息， fmt=high 获取高清视屏地址 ||

== Ajax规范 ==
使用Ajax的目的：为了RaspCTL提供的服务可以同时被WAP， Android APP, IOS APP使用，RaspCTL服务均以Ajax形式提供。希望Plugins开发者也遵照这个规约，但不强制。

类库中，只要被标志@classmethod的方法，会直接暴露成Ajax服务，如：
{{{
class Foo:
    @classmethod
    def hello(cls, arg1, arg2): 
        return {msg: 'Hello Ajax[%s %s]' % (arg1, arg2)}
}}}
Ajax服务地址为：{{{http://xxx.xxx.xxx.xxx:8000/api?data={"name":"Foo.hello", "args":["stone2083", "connie2083"]}}}}
服务信息为：
{{{
{
  status: "Success",
  message: "Success",
  api: {
    args: [ ],
    name: "Foo.hello"
  },
  result: {
    msg: "Hello Ajax[stone2083 connie2083]"
  }
}
}}}

== Plugins规范 ==
{{{
youku --> 插件名字
    __init__.py --> 插件程序
    index.html --> 插件模板 【可选择】
}}}
__init__.py 内容为：
{{{
from rasplib import Plugin
urls = (
    '/', 'Index',
)

# 必须创建plugin实例，参数分别为插件名，作者名，版本号， 支持功能的urls
#其中，plugin中包含RaspCTL类库的所有方法，可直接调用
plugin = Plugin('youku','stone2083', '0.1', urls)

#web.py写法，插件规范并不引入新的学习成本。
class Index:
    def GET(self):
        return 'youku-NotSupported.'  #可以直接输出
        #return plugin.render.index()  #可以渲染某个模板信息
}}}

= 写在最后 =
  * RaspCTL作者联系信息：stone2083#yahoo.cn 程序的任何问题可直接联系这个邮箱
  * 招募UED设计前端界面 0.1.0前端非常糟糕，急待重构
  * 招募Plugin开发者，丰富RaspCTL
  * 期待小白鼠适用RaspCTL